export const Moves: {[k: string]: ModdedMoveData} = {
	//Dexit Moves
	absorb: {
		inherit: true,
		isNonstandard: "Past",
	},
	accelerock: {
		inherit: true,
		isNonstandard: "Past",
	},
	acid: {
		inherit: true,
		isNonstandard: "Past",
	},
	aircutter: {
		inherit: true,
		isNonstandard: "Past",
	},
	aromaticmist: {
		inherit: true,
		isNonstandard: "Past",
	},
	assurance: {
		inherit: true,
		isNonstandard: "Past",
	},
	astonish: {
		inherit: true,
		isNonstandard: "Past",
	},
	astralbarrage: {
		inherit: true,
		isNonstandard: "Past",
	},
	attackorder: {
		inherit: true,
		isNonstandard: "Past",
	},
	barbbarrage: {
		inherit: true,
		isNonstandard: "Past",
	},
	behemothbash: {
		inherit: true,
		isNonstandard: "Past",
	},
	behemothblade: {
		inherit: true,
		isNonstandard: "Past",
	},
	belch: {
		inherit: true,
		isNonstandard: "Past",
	},
	bind: {
		inherit: true,
		isNonstandard: "Past",
	},
	bittermalice: {
		inherit: true,
		isNonstandard: "Past",
	},
	blazingtorque: {
		inherit: true,
		isNonstandard: "Past",
	},
	bleakwindstorm: {
		inherit: true,
		isNonstandard: "Past",
	},
	ceaselessedge: {
		inherit: true,
		isNonstandard: "Past",
	},
	celebrate: {
		inherit: true,
		isNonstandard: "Past",
	},
	chloroblast: {
		inherit: true,
		isNonstandard: "Past",
	},
	circlethrow: {
		inherit: true,
		isNonstandard: "Past",
	},
	combattorque: {
		inherit: true,
		isNonstandard: "Past",
	},
	cut: {
		inherit: true,
		isNonstandard: "Past",
	},
	defendorder: {
		inherit: true,
		isNonstandard: "Past",
	},
	diamondstorm: {
		inherit: true,
		isNonstandard: "Past",
	},
	direclaw: {
		inherit: true,
		isNonstandard: "Past",
	},
	doodle: {
		inherit: true,
		isNonstandard: "Past",
	},
	dragonenergy: {
		inherit: true,
		isNonstandard: "Past",
	},
	dragonrush: {
		inherit: true,
		isNonstandard: "Past",
	},
	drumbeating: {
		inherit: true,
		isNonstandard: "Past",
	},
	dynamaxcannon: {
		inherit: true,
		isNonstandard: "Past",
	},
	eerieimpulse: {
		inherit: true,
		isNonstandard: "Past",
	},
	electroball: {
		inherit: true,
		isNonstandard: "Past",
	},
	fairywind: {
		inherit: true,
		isNonstandard: "Past",
	},
	fierywrath: {
		inherit: true,
		isNonstandard: "Past",
	},
	firelash: {
		inherit: true,
		isNonstandard: "Past",
	},
	forcepalm: {
		inherit: true,
		isNonstandard: "Past",
	},
	freezingglare: {
		inherit: true,
		isNonstandard: "Past",
	},
	glaciallance: {
		inherit: true,
		isNonstandard: "Past",
	},
	glare: {
		inherit: true,
		isNonstandard: "Past",
	},
	happyhour: {
		inherit: true,
		isNonstandard: "Past",
	},
	healbell: {
		inherit: true,
		isNonstandard: "Past",
	},
	healorder: {
		inherit: true,
		isNonstandard: "Past",
	},
	holdhands: {
		inherit: true,
		isNonstandard: "Past",
	},
	hyperspacefury: {
		inherit: true,
		isNonstandard: "Past",
	},
	hyperspacehole: {
		inherit: true,
		isNonstandard: "Past",
	},
	inferno: {
		inherit: true,
		isNonstandard: "Past",
	},
	infernalparade: {
		inherit: true,
		isNonstandard: "Past",
	},
	jetpunch: {
		inherit: true,
		isNonstandard: "Past",
	},
	lunarblessing: {
		inherit: true,
		isNonstandard: "Past",
	},
	lunardance: {
		inherit: true,
		isNonstandard: "Past",
	},
	magicroom: {
		inherit: true,
		isNonstandard: "Past",
	},
	magicaltorque: {
		inherit: true,
		isNonstandard: "Past",
	},
	magmastorm: {
		inherit: true,
		isNonstandard: "Past",
	},
	mortalspin: {
		inherit: true,
		isNonstandard: "Past",
	},
	mudshot: {
		inherit: true,
		isNonstandard: "Past",
	},
	mysticalpower: {
		inherit: true,
		isNonstandard: "Past",
	},
	nightdaze: {
		inherit: true,
		isNonstandard: "Past",
	},
	noretreat: {
		inherit: true,
		isNonstandard: "Past",
	},
	noxioustorque: {
		inherit: true,
		isNonstandard: "Past",
	},
	orderup: {
		inherit: true,
		isNonstandard: "Past",
	},
	originpulse: {
		inherit: true,
		isNonstandard: "Past",
	},
	payday: {
		inherit: true,
		isNonstandard: "Past",
	},
	poisonpowder: {
		inherit: true,
		isNonstandard: "Past",
	},
	precipiceblades: {
		inherit: true,
		isNonstandard: "Past",
	},
	present: {
		inherit: true,
		isNonstandard: "Past",
	},
	psyshieldbash: {
		inherit: true,
		isNonstandard: "Past",
	},
	relicsong: {
		inherit: true,
		isNonstandard: "Past",
	},
	roaroftime: {
		inherit: true,
		isNonstandard: "Past",
	},
	sandsearstorm: {
		inherit: true,
		isNonstandard: "Past",
	},
	shadowforce: {
		inherit: true,
		isNonstandard: "Past",
	},
	sludgewave: {
		inherit: true,
		isNonstandard: "Past",
	},
	snipeshot: {
		inherit: true,
		isNonstandard: "Past",
	},
	spacialrend: {
		inherit: true,
		isNonstandard: "Past",
	},
	spicyextract: {
		inherit: true,
		isNonstandard: "Past",
	},
	springtidestorm: {
		inherit: true,
		isNonstandard: "Past",
	},
	steameruption: {
		inherit: true,
		isNonstandard: "Past",
	},
	surgingstrikes: {
		inherit: true,
		isNonstandard: "Past",
	},
	terablast: {
		inherit: true,
		isNonstandard: "Past",
	},
	thundercage: {
		inherit: true,
		isNonstandard: "Past",
	},
	thunderouskick: {
		inherit: true,
		isNonstandard: "Past",
	},
	toxic: {
		inherit: true,
		isNonstandard: "Past",
	},
	triplearrows: {
		inherit: true,
		isNonstandard: "Past",
	},
	vcreate: {
		inherit: true,
		isNonstandard: "Past",
	},
	victorydance: {
		inherit: true,
		isNonstandard: "Past",
	},
	wickedblow: {
		inherit: true,
		isNonstandard: "Past",
	},
	wickedtorque: {
		inherit: true,
		isNonstandard: "Past",
	},
	wildboltstorm: {
		inherit: true,
		isNonstandard: "Past",
	},
	workup: {
		inherit: true,
		isNonstandard: "Past",
	},
	
	//Undexit Moves
	aeroblast: {
		inherit: true,
		isNonstandard: null,
	},
	anchorshot: {
		inherit: true,
		isNonstandard: null,
	},
	aurawheel: {
		inherit: true,
		isNonstandard: null,
	},
	boneclub: {
		inherit: true,
		isNonstandard: null,
	},
	bonemerang: {
		inherit: true,
		isNonstandard: null,
	},
	clangingscales: {
		inherit: true,
		isNonstandard: null,
	},
	clangoroussoul: {
		inherit: true,
		isNonstandard: null,
	},
	conversion: {
		inherit: true,
		isNonstandard: null,
	},
	conversion2: {
		inherit: true,
		isNonstandard: null,
	},
	coreenforcer: {
		inherit: true,
		isNonstandard: null,
	},
	doubleironbash: {
		inherit: true,
		isNonstandard: null,
	},
	geomancy: {
		inherit: true,
		isNonstandard: null,
	},
	landswrath: {
		inherit: true,
		isNonstandard: null,
	},
	naturesmadness: {
		inherit: true,
		isNonstandard: null,
	},
	oblivionwing: {
		inherit: true,
		isNonstandard: null,
	},
	psychoboost: {
		inherit: true,
		isNonstandard: null,
	},
	sacredfire: {
		inherit: true,
		isNonstandard: null,
	},
	seedflare: {
		inherit: true,
		isNonstandard: null,
	},
	shadowbone: {
		inherit: true,
		isNonstandard: null,
	},
	sketch: {
		inherit: true,
		isNonstandard: null,
		onHit(target, source) {
			const disallowedMoves = [
				'chatter', 'sketch', 'struggle', 'freezingglare', 'thunderouskick', 'fierywrath', 'psystrike', 'aeroblast', 'sacredfire', 'mistball', 'lusterpurge', 
				'originpulse', 'precipiceblades', 'dragonascent', 'doomdesire', 'psychoboost', 'mysticalpower', 'roaroftime', 'spacialrend', 'magmastorm', 'crushgrip', 
				'shadowforce', 'lunardance', 'takeheart', 'heartswap', 'darkvoid', 'seedflare', 'judgement', 'vcreate', 'bleakwindstorm', 'wildboltstorm', 'fusionflare', 
				'blueflare', 'fusionbolt', 'boltstrike', 'sandsearstorm', 'glaciate', 'iceburn', 'freezeshock', 'secretsword', 'relicsong', 'technoblast', 'geomancy', 
				'yveltal', 'landswrath', 'thousandarrows', 'thousandwaves', 'coreenforcer', 'diamondstorm', 'hyperspacefury', 'hyperspacehole', 'steameruption', 'multiattack', 
				'naturesmadness', 'sunsteelstrike', 'moongeistbeam', 'prismaticlaser', 'photongeyser', 'fleurcannon', 'spectralthief', 'plasmafists', 'doubleironbash', 
				'behemothblade', 'behemothbash', 'eternabeam', 'dynamaxcannon', 'wickedblow', 'surgingstrikes', 'junglehealing', 'thundercage', 'dragonenergy', 'glaciallance', 
				'springtidestorm', 'ruination', 'collisioncourse', 'electrodrift', 'bodycharge', 'mindclaw', 'spiritroar', 'dynamicassault', 'chasedown',
			];
			const move = target.lastMove;
			if (source.transformed || !move || source.moves.includes(move.id)) return false;
			if (disallowedMoves.includes(move.id) || move.isZ || move.isMax || move.category === 'Status') return false;
			const sketchIndex = source.moves.indexOf('sketch');
			if (sketchIndex < 0) return false;
			const sketchedMove = {
				move: move.name,
				id: move.id,
				pp: move.pp,
				maxpp: move.pp,
				target: move.target,
				disabled: false,
				used: false,
			};
			source.moveSlots[sketchIndex] = sketchedMove;
			source.baseMoveSlots[sketchIndex] = sketchedMove;
			this.add('-activate', source, 'move: Sketch', move.name);
		},
	},
	tailglow: {
		inherit: true,
		isNonstandard: null,
	},
	thousandarrows: {
		inherit: true,
		isNonstandard: null,
	},
	thousandwaves: {
		inherit: true,
		isNonstandard: null,
	},
	
	
	armthrust: {
		inherit: true,
		basePower: 25,
	},
	boltbeak: {
		inherit: true,
		basePower: 80,
		basePowerCallback(pokemon, target, move) {
			if (target.newlySwitched || this.queue.willMove(target)) {
				this.debug('Bolt Beak damage boost');
				return move.basePower * 1.3;
			}
			this.debug('Bolt Beak NOT boosted');
			return move.basePower;
		},
		shortDesc: "1.3x power if user moves before the target.",
		isNonstandard: null,
	},
	brickbreak: {
		inherit: true,
		basePower: 85,
	},
	curse: {
		inherit: true,
		condition: {
			onStart(pokemon, source, effect) {
				if (effect.effectType === 'Ability') {
					this.add('-start', pokemon, 'Curse', '[from] ability: Cursed Body', '[of] ' + source);
				} else {
					this.add('-start', pokemon, 'Curse', '[of] ' + source);
				}
			},
			onResidualOrder: 12,
			onResidual(pokemon) {
				this.damage(pokemon.baseMaxhp / 4);
			},
		},
	},
	disable: {
		inherit: true,
		condition: {
			duration: 5,
			noCopy: true, // doesn't get copied by Baton Pass
			onStart(pokemon, source, effect) {
				// The target hasn't taken its turn, or Cursed Body activated and the move was not used through Dancer or Instruct
				if (
					this.queue.willMove(pokemon) ||
					(pokemon === this.activePokemon && this.activeMove && !this.activeMove.isExternal)
				) {
					this.effectState.duration--;
				}
				if (!pokemon.lastMove) {
					this.debug(`Pokemon hasn't moved yet`);
					return false;
				}
				for (const moveSlot of pokemon.moveSlots) {
					if (moveSlot.id === pokemon.lastMove.id) {
						if (!moveSlot.pp) {
							this.debug('Move out of PP');
							return false;
						}
					}
				}
				this.add('-start', pokemon, 'Disable', pokemon.lastMove.name);
				this.effectState.move = pokemon.lastMove.id;
			},
			onResidualOrder: 17,
			onEnd(pokemon) {
				this.add('-end', pokemon, 'Disable');
			},
			onBeforeMovePriority: 7,
			onBeforeMove(attacker, defender, move) {
				if (attacker.hasAbility('ignorance')) return;
				if (!move.isZ && move.id === this.effectState.move) {
					this.add('cant', attacker, 'Disable', move);
					return false;
				}
			},
			onDisableMove(pokemon) {
				for (const moveSlot of pokemon.moveSlots) {
					if (moveSlot.id === this.effectState.move) {
						pokemon.disableMove(moveSlot.id);
					}
				}
			},
		},
	},
	dragonclaw: {
		inherit: true,
		basePower: 85,
	},
	encore: {
		inherit: true,
		condition: {
			duration: 3,
			noCopy: true, // doesn't get copied by Z-Baton Pass
			onStart(target) {
				let move: Move | ActiveMove | null = target.lastMove;
				if (!move || target.volatiles['dynamax']) return false;

				if (move.isMax && move.baseMove) move = this.dex.moves.get(move.baseMove);
				const moveIndex = target.moves.indexOf(move.id);
				if (move.isZ || move.flags['failencore'] || !target.moveSlots[moveIndex] || target.moveSlots[moveIndex].pp <= 0) {
					// it failed
					return false;
				}
				this.effectState.move = move.id;
				this.add('-start', target, 'Encore');
				if (!this.queue.willMove(target)) {
					this.effectState.duration++;
				}
			},
			onOverrideAction(pokemon, target, move) {
				if (pokemon.hasAbility('ignorance')) return;
				if (move.id !== this.effectState.move) return this.effectState.move;
			},
			onResidualOrder: 16,
			onResidual(target) {
				if (target.moves.includes(this.effectState.move) &&
					target.moveSlots[target.moves.indexOf(this.effectState.move)].pp <= 0) {
					// early termination if you run out of PP
					target.removeVolatile('encore');
				}
			},
			onEnd(target) {
				this.add('-end', target, 'Encore');
			},
			onDisableMove(pokemon) {
				if (pokemon.hasAbility('ignorance')) return;
				if (!this.effectState.move || !pokemon.hasMove(this.effectState.move)) {
					return;
				}
				for (const moveSlot of pokemon.moveSlots) {
					if (moveSlot.id !== this.effectState.move) {
						pokemon.disableMove(moveSlot.id);
					}
				}
			},
		},
	},
	firefang: {
		inherit: true,
		basePower: 75,
	},
	firepunch: {
		inherit: true,
		basePower: 85,
	},
	fishiousrend: {
		inherit: true,
		basePower: 80,
		basePowerCallback(pokemon, target, move) {
			if (target.newlySwitched || this.queue.willMove(target)) {
				this.debug('Fishious Rend damage boost');
				return move.basePower * 1.3;
			}
			this.debug('Fishious Rend NOT boosted');
			return move.basePower;
		},
		shortDesc: "1.3x power if user moves before the target.",
		isNonstandard: null,
	},
	gigatonhammer: {
		inherit: true,
		onDisableMove(pokemon) {
			if (pokemon.hasAbility('ignorance')) return;
			if (pokemon.lastMove?.id === 'gigatonhammer') pokemon.disableMove('gigatonhammer');
		},
	},
	glaciate: {
		inherit: true,
		basePower: 95,
	},
	hammerarm: {
		inherit: true,
		basePower: 120,
		pp: 5,
	},
	healblock: {
		inherit: true,
		condition: {
			duration: 5,
			durationCallback(target, source, effect) {
				if (source?.hasAbility('persistent')) {
					this.add('-activate', source, 'ability: Persistent', '[move] Heal Block');
					return 7;
				}
				return 5;
			},
			onStart(pokemon, source) {
				this.add('-start', pokemon, 'move: Heal Block');
				source.moveThisTurnResult = true;
			},
			onDisableMove(pokemon) {
				if (pokemon.hasAbility('ignorance')) return;
				for (const moveSlot of pokemon.moveSlots) {
					if (this.dex.moves.get(moveSlot.id).flags['heal']) {
						pokemon.disableMove(moveSlot.id);
					}
				}
			},
			onBeforeMovePriority: 6,
			onBeforeMove(pokemon, target, move) {
				if (move.flags['heal'] && !move.isZ && !move.isMax) {
					this.add('cant', pokemon, 'move: Heal Block', move);
					return false;
				}
			},
			onModifyMove(move, pokemon, target) {
				if (pokemon.hasAbility('ignorance')) return;
				if (move.flags['heal'] && !move.isZ && !move.isMax) {
					this.add('cant', pokemon, 'move: Heal Block', move);
					return false;
				}
			},
			onResidualOrder: 20,
			onEnd(pokemon) {
				this.add('-end', pokemon, 'move: Heal Block');
			},
			onTryHeal(damage, target, source, effect) {
				if ((effect?.id === 'zpower') || this.effectState.isZ) return damage;
				return false;
			},
			onRestart(target, source) {
				this.add('-fail', target, 'move: Heal Block'); // Succeeds to supress downstream messages
				if (!source.moveThisTurnResult) {
					source.moveThisTurnResult = false;
				}
			},
		},
	},
	hiddenpower: {
		inherit: true,
		isNonstandard: null,
		onTryMove(pokemon, target, move) {
			if (pokemon.species.name === 'Unown' || pokemon.species.name === 'Uninown' || move.hasBounced) {
				return;
			}
			this.add('-fail', pokemon, 'move: Hidden Power');
			this.hint("Only a Pokemon whose form is Unown or Uninown can use this move.");
			return null;
		},
		shortDesc: "This move fails unless used by Unown or Uninown.",
	},
	hiddenpowerbug: {
		inherit: true,
		isNonstandard: null,
		onTryMove(pokemon, target, move) {
			if (pokemon.species.name === 'Unown' || pokemon.species.name === 'Uninown' || move.hasBounced) {
				return;
			}
			this.add('-fail', pokemon, 'move: Hidden Power');
			this.hint("Only a Pokemon whose form is Unown or Uninown can use this move.");
			return null;
		},
		shortDesc: "This move fails unless used by Unown or Uninown.",
	},
	hiddenpowerdark: {
		inherit: true,
		isNonstandard: null,
		onTryMove(pokemon, target, move) {
			if (pokemon.species.name === 'Unown' || pokemon.species.name === 'Uninown' || move.hasBounced) {
				return;
			}
			this.add('-fail', pokemon, 'move: Hidden Power');
			this.hint("Only a Pokemon whose form is Unown or Uninown can use this move.");
			return null;
		},
		shortDesc: "This move fails unless used by Unown or Uninown.",
	},
	hiddenpowerdragon: {
		inherit: true,
		isNonstandard: null,
		onTryMove(pokemon, target, move) {
			if (pokemon.species.name === 'Unown' || pokemon.species.name === 'Uninown' || move.hasBounced) {
				return;
			}
			this.add('-fail', pokemon, 'move: Hidden Power');
			this.hint("Only a Pokemon whose form is Unown or Uninown can use this move.");
			return null;
		},
		shortDesc: "This move fails unless used by Unown or Uninown.",
	},
	hiddenpowerelectric: {
		inherit: true,
		isNonstandard: null,
		onTryMove(pokemon, target, move) {
			if (pokemon.species.name === 'Unown' || pokemon.species.name === 'Uninown' || move.hasBounced) {
				return;
			}
			this.add('-fail', pokemon, 'move: Hidden Power');
			this.hint("Only a Pokemon whose form is Unown or Uninown can use this move.");
			return null;
		},
		shortDesc: "This move fails unless used by Unown or Uninown.",
	},
	hiddenpowerfighting: {
		inherit: true,
		isNonstandard: null,
		onTryMove(pokemon, target, move) {
			if (pokemon.species.name === 'Unown' || pokemon.species.name === 'Uninown' || move.hasBounced) {
				return;
			}
			this.add('-fail', pokemon, 'move: Hidden Power');
			this.hint("Only a Pokemon whose form is Unown or Uninown can use this move.");
			return null;
		},
		shortDesc: "This move fails unless used by Unown or Uninown.",
	},
	hiddenpowerfire: {
		inherit: true,
		isNonstandard: null,
		onTryMove(pokemon, target, move) {
			if (pokemon.species.name === 'Unown' || pokemon.species.name === 'Uninown' || move.hasBounced) {
				return;
			}
			this.add('-fail', pokemon, 'move: Hidden Power');
			this.hint("Only a Pokemon whose form is Unown or Uninown can use this move.");
			return null;
		},
		shortDesc: "This move fails unless used by Unown or Uninown.",
	},
	hiddenpowerflying: {
		inherit: true,
		isNonstandard: null,
		onTryMove(pokemon, target, move) {
			if (pokemon.species.name === 'Unown' || pokemon.species.name === 'Uninown' || move.hasBounced) {
				return;
			}
			this.add('-fail', pokemon, 'move: Hidden Power');
			this.hint("Only a Pokemon whose form is Unown or Uninown can use this move.");
			return null;
		},
		shortDesc: "This move fails unless used by Unown or Uninown.",
	},
	hiddenpowerghost: {
		inherit: true,
		isNonstandard: null,
		onTryMove(pokemon, target, move) {
			if (pokemon.species.name === 'Unown' || pokemon.species.name === 'Uninown' || move.hasBounced) {
				return;
			}
			this.add('-fail', pokemon, 'move: Hidden Power');
			this.hint("Only a Pokemon whose form is Unown or Uninown can use this move.");
			return null;
		},
		shortDesc: "This move fails unless used by Unown or Uninown.",
	},
	hiddenpowergrass: {
		inherit: true,
		isNonstandard: null,
		onTryMove(pokemon, target, move) {
			if (pokemon.species.name === 'Unown' || pokemon.species.name === 'Uninown' || move.hasBounced) {
				return;
			}
			this.add('-fail', pokemon, 'move: Hidden Power');
			this.hint("Only a Pokemon whose form is Unown or Uninown can use this move.");
			return null;
		},
		shortDesc: "This move fails unless used by Unown or Uninown.",
	},
	hiddenpowerground: {
		inherit: true,
		isNonstandard: null,
		onTryMove(pokemon, target, move) {
			if (pokemon.species.name === 'Unown' || pokemon.species.name === 'Uninown' || move.hasBounced) {
				return;
			}
			this.add('-fail', pokemon, 'move: Hidden Power');
			this.hint("Only a Pokemon whose form is Unown or Uninown can use this move.");
			return null;
		},
		shortDesc: "This move fails unless used by Unown or Uninown.",
	},
	hiddenpowerice: {
		inherit: true,
		isNonstandard: null,
		onTryMove(pokemon, target, move) {
			if (pokemon.species.name === 'Unown' || pokemon.species.name === 'Uninown' || move.hasBounced) {
				return;
			}
			this.add('-fail', pokemon, 'move: Hidden Power');
			this.hint("Only a Pokemon whose form is Unown or Uninown can use this move.");
			return null;
		},
		shortDesc: "This move fails unless used by Unown or Uninown.",
	},
	hiddenpowerpoison: {
		inherit: true,
		isNonstandard: null,
		onTryMove(pokemon, target, move) {
			if (pokemon.species.name === 'Unown' || pokemon.species.name === 'Uninown' || move.hasBounced) {
				return;
			}
			this.add('-fail', pokemon, 'move: Hidden Power');
			this.hint("Only a Pokemon whose form is Unown or Uninown can use this move.");
			return null;
		},
		shortDesc: "This move fails unless used by Unown or Uninown.",
	},
	hiddenpowerpsychic: {
		inherit: true,
		isNonstandard: null,
		onTryMove(pokemon, target, move) {
			if (pokemon.species.name === 'Unown' || pokemon.species.name === 'Uninown' || move.hasBounced) {
				return;
			}
			this.add('-fail', pokemon, 'move: Hidden Power');
			this.hint("Only a Pokemon whose form is Unown or Uninown can use this move.");
			return null;
		},
		shortDesc: "This move fails unless used by Unown or Uninown.",
	},
	hiddenpowerrock: {
		inherit: true,
		isNonstandard: null,
		onTryMove(pokemon, target, move) {
			if (pokemon.species.name === 'Unown' || pokemon.species.name === 'Uninown' || move.hasBounced) {
				return;
			}
			this.add('-fail', pokemon, 'move: Hidden Power');
			this.hint("Only a Pokemon whose form is Unown or Uninown can use this move.");
			return null;
		},
		shortDesc: "This move fails unless used by Unown or Uninown.",
	},
	hiddenpowersteel: {
		inherit: true,
		isNonstandard: null,
		onTryMove(pokemon, target, move) {
			if (pokemon.species.name === 'Unown' || pokemon.species.name === 'Uninown' || move.hasBounced) {
				return;
			}
			this.add('-fail', pokemon, 'move: Hidden Power');
			this.hint("Only a Pokemon whose form is Unown or Uninown can use this move.");
			return null;
		},
		shortDesc: "This move fails unless used by Unown or Uninown.",
	},
	hiddenpowerwater: {
		inherit: true,
		isNonstandard: null,
		onTryMove(pokemon, target, move) {
			if (pokemon.species.name === 'Unown' || pokemon.species.name === 'Uninown' || move.hasBounced) {
				return;
			}
			this.add('-fail', pokemon, 'move: Hidden Power');
			this.hint("Only a Pokemon whose form is Unown or Uninown can use this move.");
			return null;
		},
		shortDesc: "This move fails unless used by Unown or Uninown.",
	},
	icefang: {
		inherit: true,
		basePower: 75,
	},
	icehammer: {
		inherit: true,
		accuracy: 100,
		basePower: 120,
		pp: 5,
	},
	icepunch: {
		inherit: true,
		basePower: 85,
	},
	imprison: {
		inherit: true,
		condition: {
			noCopy: true,
			onStart(target) {
				this.add('-start', target, 'move: Imprison');
			},
			onFoeDisableMove(pokemon) {
				if (pokemon.hasAbility('ignorance')) return;
				for (const moveSlot of this.effectState.source.moveSlots) {
					if (moveSlot.id === 'struggle') continue;
					pokemon.disableMove(moveSlot.id, 'hidden');
				}
				pokemon.maybeDisabled = true;
			},
			onFoeBeforeMovePriority: 4,
			onFoeBeforeMove(attacker, defender, move) {
				if (attacker.hasAbility('ignorance')) return;
				if (move.id !== 'struggle' && this.effectState.source.hasMove(move.id) && !move.isZ && !move.isMax) {
					this.add('cant', attacker, 'move: Imprison', move);
					return false;
				}
			},
		},
	},
	knockoff: {
		inherit: true,
		basePower: 50,
		onBasePower(basePower, source, target, move) {
			const item = target.getItem();
			if (!this.singleEvent('TakeItem', item, target.itemData, target, target, move, item)) return;
			if (item.id) {
				return this.chainModify(1.2);
			}
		},
		shortDesc: "1.2x damage if foe holds an item. Removes item.",
	},
	lastrespects: {
		inherit: true,
		basePowerCallback(pokemon, target, move) {
			return 50 + 15 * pokemon.side.totalFainted;
		},
		shortDesc: "+15 power for each time a party member fainted.",
	},
	lusterpurge: {
		inherit: true,
		basePower: 90,
		isNonstandard: null,
	},
	makeitrain: {
		inherit: true,
		basePower: 100,
	},
	meteorbeam: {
		inherit: true,
		shortDesc: "+1 SpA on turn 1. Hits turn 2. 1 turn in sun.",
		onTryMove(attacker, defender, move) {
			if (attacker.removeVolatile(move.id)) {
				return;
			}
			this.add('-prepare', attacker, move.name);
			this.boost({spa: 1}, attacker, attacker, move);
			if (this.field.isWeather('sandstorm')) {
				this.attrLastMove('[still]');
				this.addMove('-anim', attacker, move.name, defender);
				return;
			}
			if (!this.runEvent('ChargeMove', attacker, defender, move)) {
				return;
			}
			attacker.addVolatile('twoturnmove', defender);
			return null;
		},
	},
	mistball: {
		inherit: true,
		basePower: 90,
		isNonstandard: null,
	},
	populationbomb: {
		inherit: true,
		basePower: 15,
	},
	pounce: {
		inherit: true,
		basePower: 80,
	},
	ragefist: {
		inherit: true,
		basePowerCallback(pokemon) {
			return Math.min(140, 50 + 15 * pokemon.timesAttacked);
		},
		shortDesc: "+15 power for each time user was hit. Max 6 hits.",
	},
	ragingbull: {
		inherit: true,
		onModifyType(move, pokemon) {
			switch (pokemon.species.name) {
			case 'Tauros-Paldea-Combat':
				move.type = 'Fighting';
				break;
			case 'Tauros-Paldea-Blaze':
				move.type = 'Fire';
				break;
			case 'Tauros-Paldea-Aqua':
				move.type = 'Water';
				break;
			case 'Taurot':
				move.type = 'Flying';
				break;
			case 'Minowing':
				move.type = 'Flying';
				break;
			}
		},
	},
	saltcure: {
		inherit: true,
		shortDesc: "Deals 1/16 max HP each turn; 1/8 on Steel, Water.",
		condition: {
			onStart(pokemon, source) {
				this.add('-start', pokemon, 'move: Salt Cure', '[of] ' + source);
			},
			onResidualOrder: 13,
			onResidual(pokemon) {
				this.damage(pokemon.baseMaxhp / (pokemon.hasType(['Water', 'Steel']) ? 8 : 16));
			},
			onEnd(pokemon) {
				this.add('-end', pokemon, 'move: Salt Cure');
			},
		},
	},
	solarbeam: {
		inherit: true,
		shortDesc: "+1 SpA on turn 1. Hits turn 2. 1 turn in sun.",
		onTryMove(attacker, defender, move) {
			if (attacker.removeVolatile(move.id)) {
				return;
			}
			this.add('-prepare', attacker, move.name);
			this.boost({spa: 1}, attacker, attacker, move);
			if (['sunnyday', 'desolateland'].includes(attacker.effectiveWeather())) {
				this.attrLastMove('[still]');
				this.addMove('-anim', attacker, move.name, defender);
				return;
			}
			if (!this.runEvent('ChargeMove', attacker, defender, move)) {
				return;
			}
			attacker.addVolatile('twoturnmove', defender);
			return null;
		},
		onBasePower(basePower, pokemon, target) {
			const weakWeathers = ['raindance', 'primordialsea', 'sandstorm', 'hail', 'snow'];
			if (weakWeathers.includes(pokemon.effectiveWeather())) {
				this.debug('weakened by weather');
				return this.chainModify(0.5);
			}
		},
	},
	stealthrock: {
		inherit: true,
		condition: {
			// this is a side condition
			onSideStart(side) {
				this.add('-sidestart', side, 'move: Stealth Rock');
			},
			onEntryHazard(pokemon) {
				if (pokemon.hasItem('heavydutyboots')) return;
				const typeMod = this.clampIntRange(pokemon.runEffectiveness(this.dex.getActiveMove('stealthrock')), -6, 6);
				this.damage(pokemon.maxhp / (8 - typeMod * 2));
			},
		},
	},
	taunt: {
		inherit: true,
		condition: {
			duration: 3,
			onStart(target) {
				if (target.activeTurns && !this.queue.willMove(target)) {
					this.effectState.duration++;
				}
				this.add('-start', target, 'move: Taunt');
			},
			onResidualOrder: 15,
			onEnd(target) {
				this.add('-end', target, 'move: Taunt');
			},
			onDisableMove(pokemon) {
				if (pokemon.hasAbility('ignorance')) return;
				for (const moveSlot of pokemon.moveSlots) {
					const move = this.dex.moves.get(moveSlot.id);
					if (move.id === 'prepareattack' && ['yorlator', 'mranovo', 'curtowal'].includes(pokemon.species.id)) return;
					if (move.category === 'Status' && move.id !== 'mefirst') {
						pokemon.disableMove(moveSlot.id);
					}
				}
			},
			onBeforeMovePriority: 5,
			onBeforeMove(attacker, defender, move) {
				if (attacker.hasAbility('ignorance')) return;
				if (!move.isZ && !move.isMax && move.category === 'Status' && move.id !== 'mefirst') {
					this.add('cant', attacker, 'move: Taunt', move);
					return false;
				}
			},
		},
	},
	throatchop: {
		inherit: true,
		condition: {
			duration: 2,
			onStart(target) {
				this.add('-start', target, 'Throat Chop', '[silent]');
			},
			onDisableMove(pokemon) {
				if (pokemon.hasAbility('ignorance')) return;
				for (const moveSlot of pokemon.moveSlots) {
					if (this.dex.moves.get(moveSlot.id).flags['sound']) {
						pokemon.disableMove(moveSlot.id);
					}
				}
			},
			onBeforeMovePriority: 6,
			onBeforeMove(pokemon, target, move) {
				if (pokemon.hasAbility('ignorance')) return;
				if (!move.isZ && !move.isMax && move.flags['sound']) {
					this.add('cant', pokemon, 'move: Throat Chop');
					return false;
				}
			},
			onModifyMove(move, pokemon, target) {
				if (pokemon.hasAbility('ignorance')) return;
				if (!move.isZ && !move.isMax && move.flags['sound']) {
					this.add('cant', pokemon, 'move: Throat Chop');
					return false;
				}
			},
			onResidualOrder: 22,
			onEnd(target) {
				this.add('-end', target, 'Throat Chop', '[silent]');
			},
		},
	},
	thunderfang: {
		inherit: true,
		basePower: 75,
	},
	thunderpunch: {
		inherit: true,
		basePower: 85,
	},
	torment: {
		inherit: true,
		condition: {
			noCopy: true,
			onStart(pokemon, source, effect) {
				if (pokemon.volatiles['dynamax']) {
					delete pokemon.volatiles['torment'];
					return false;
				}
				if (effect?.id === 'gmaxmeltdown') this.effectState.duration = 3;
				this.add('-start', pokemon, 'Torment');
			},
			onEnd(pokemon) {
				this.add('-end', pokemon, 'Torment');
			},
			onDisableMove(pokemon) {
				if (pokemon.hasAbility('ignorance')) return;
				if (pokemon.lastMove && pokemon.lastMove.id !== 'struggle') pokemon.disableMove(pokemon.lastMove.id);
			},
		},
	},
	wildcharge: {
		inherit: true,
		basePower: 120,
		shortDesc: "Has 33% recoil.",
		recoil: [33, 100],
	},
	
	dash: {
		num: -1,
		accuracy: 100,
		basePower: 80,
		category: "Physical",
		name: "Dash",
		pp: 15,
		priority: 0,
		flags: {contact: 1, protect: 1, mirror: 1},
		noSketch: true,
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Giga Impact", target);
		},
		secondary: null,
		target: "normal",
		type: "Normal",
	},
	
	//Roovnen
	flowerpattern: {
		num: 919,
		accuracy: 85,
		basePower: 100,
		category: "Special",
		shortDesc: "Super effective on Ground, Rock and Water.",
		name: "Flower Pattern",
		pp: 10,
		priority: 0,
		flags: {protect: 1, mirror: 1},
		onEffectiveness(typeMod, target, type) {
			if (type === 'Ground' || type === 'Rock' || type === 'Water') return 1;
		},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Petal Dance", target);
		},
		secondary: null,
		target: "normal",
		type: "Fairy",
	},
	foreshadowing: {
		num: 920,
		accuracy: 100,
		basePower: 100,
		category: "Physical",
		shortDesc: "Hits two turns after being used.",
		name: "Foreshadowing",
		pp: 10,
		priority: 0,
		flags: {},
		ignoreImmunity: true,
		isFutureMove: true,
		onTry(source, target) {
			if (!target.side.addSlotCondition(target, 'futuremove')) return false;
			Object.assign(target.side.slotConditions[target.position]['futuremove'], {
				duration: 3,
				move: 'foreshadowing',
				source: source,
				moveData: {
					id: 'foreshadowing',
					name: "Foreshadowing",
					accuracy: 100,
					basePower: 100,
					category: "Physical",
					priority: 0,
					flags: {},
					ignoreImmunity: false,
					effectType: 'Move',
					isFutureMove: true,
					type: 'Ghost',
				},
				onPrepareHit: function(target, source, move) {
					this.attrLastMove('[still]');
					this.add('-anim', source, "Future Sight", target);
					this.add('-anim', source, "Night Shade", target);
				},
			});
			this.add('-start', source, 'move: Future Sight');
			return this.NOT_FAIL;
		},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Future Sight", target);
			this.add('-anim', source, "Night Shade", target);
		},
		secondary: null,
		target: "normal",
		type: "Ghost",
	},
	hydrovoice: {
		num: 921,
		accuracy: 95,
		basePower: 60,
		basePowerCallback(pokemon, target, move) {
			let bp = move.basePower;
			if (this.field.pseudoWeather.hydrovoice) {
				bp = move.basePower * this.field.pseudoWeather.hydrovoice.multiplier;
			}
			this.debug('BP: ' + move.basePower);
			return bp;
		},
		category: "Special",
		shortDesc: "Power increases when used on consecutive turns.",
		name: "Hydro Voice",
		pp: 10,
		priority: 0,
		flags: {protect: 1, mirror: 1, sound: 1, authentic: 1},
		onTry() {
			this.field.addPseudoWeather('hydrovoice');
		},
		condition: {
			duration: 2,
			onFieldStart() {
				this.effectState.multiplier = 1;
			},
			onFieldRestart() {
				if (this.effectState.duration !== 2) {
					this.effectState.duration = 2;
					if (this.effectState.multiplier < 5) {
						this.effectState.multiplier++;
					}
				}
			},
		},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Sparkling Aria", target);
		},
		secondary: null,
		target: "normal",
		type: "Water",
	},
	mountainbreeze: {
		num: 922,
		accuracy: 100,
		basePower: 80,
		category: "Special",
		shortDesc: "If resisted, the target will be weak to Ice.",
		name: "Mountain Breeze",
		pp: 15,
		priority: 0,
		flags: {protect: 1, mirror: 1},
		onHit(target, source, move) {
			if (!move || !target) return;
			if (target !== source && move.category !== 'Status' && target.getMoveHitData(move).typeMod < 0) {
				target.addVolatile('mountainbreeze');
			}
		},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Glaciate", target);
		},
		secondary: null,
		target: "allAdjacentFoes",
		type: "Ice",
	},
	woodbiter: {
		num: 924,
		accuracy: 100,
		basePower: 80,
		category: "Physical",
		shortDesc: "10% chance to paralyze. Super effective on Grass.",
		name: "Wood Biter",
		pp: 10,
		priority: 0,
		flags: {protect: 1, mirror: 1, contact: 1, bite: 1},
		onEffectiveness(typeMod, target, type) {
			if (type === 'Grass') return 1;
		},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Thunder Fang", target);
		},
		secondary: {
			chance: 10,
			status: 'par',
		},
		target: "normal",
		type: "Electric",
	},
	happyliving: {
		num: 929,
		accuracy: true,
		basePower: 0,
		category: "Status",
		shortDesc: "Each turn: Heals 1/8. No terrain: +1 in all stats.",
		name: "Happy Living",
		pp: 20,
		priority: 0,
		flags: {snatch: 1},
		volatileStatus: 'happyliving',
		onHit(pokemon) {
			if (this.field.isTerrain('')) {
				this.boost({atk: 1, def: 1, spa: 1, spd: 1, spe: 1}, pokemon);
			}
		},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Trick Room", target);
			this.attrLastMove('[still]');
			this.add('-anim', source, "Slack Off", target);
		},
		condition: {
			onStart(pokemon) {
				this.add('-start', pokemon, 'Happy Living');
			},
			onResidualOrder: 6,
			onResidual(pokemon) {
				this.heal(pokemon.baseMaxhp / 8);
			},
		},
		secondary: null,
		target: "self",
		type: "Normal",
	},
	darkball: {
		num: 930,
		accuracy: 100,
		basePower: 95,
		category: "Physical",
		shortDesc: "50% chance to lower the target's Atk and Def by 1.",
		name: "Dark Ball",
		pp: 5,
		priority: 0,
		flags: {bullet: 1, protect: 1, mirror: 1},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Shadow Ball", target);
		},
		secondary: {
			chance: 50,
			boosts: {
				atk: -1,
				def: -1,
			},
		},
		target: "normal",
		type: "Dark",
	},
	prepareattack: {
		num: 931,
		accuracy: true,
		basePower: 0,
		category: "Status",
		shortDesc: "Raises Damage â†‘ Next and a stat by 1.",
		name: "Prepare Attack",
		pp: 20,
		priority: 0,
		flags: {snatch: 1},
		volatileStatus: 'prepareattack',
		onAfterMoveSecondarySelf(pokemon, target, move) {
			if (pokemon.baseSpecies.baseSpecies === 'Yorlator') {
				this.boost({spa: 1}, pokemon, pokemon);
			}
			if (pokemon.baseSpecies.baseSpecies === 'Mranovo') {
				this.boost({atk: 1}, pokemon, pokemon);
			}
			if (pokemon.baseSpecies.baseSpecies === 'Curtowal') {
				this.boost({def: 1, spd: 1}, pokemon, pokemon);
			}
		},
		condition: {
			noCopy: true,
			onStart(pokemon, source, effect) {
				this.add('-start', pokemon, 'Prepare Attack');
			},
			onRestart(pokemon, source, effect) {
				this.add('-start', pokemon, 'Prepare Attack');
			},
			onBasePowerPriority: 9,
			onBasePower(basePower, attacker, defender, move) {
				if (move.category !== 'Status') {
					this.debug('PA boost');
					return this.chainModify(1.25);
				}
			},
			onMoveAborted(pokemon, target, move) {
				if (move.category !== 'Status') {
					pokemon.removeVolatile('prepareattack');
				}
			},
			onAfterMove(pokemon, target, move) {
				if (move.category !== 'Status') {
					pokemon.removeVolatile('prepareattack');
				}
			},
			onEnd(target) {
				this.add('-end', target, 'Prepare Attack', '[silent]');
			}
		},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Bulk Up", target);
		},
		secondary: null,
		target: "self",
		type: "Fighting",
	},
	slowspin: {
		num: 932,
		accuracy: 85,
		basePower: 120,
		category: "Physical",
		shortDesc: "This Pokemon always moves last.",
		name: "Slow Spin",
		pp: 5,
		priority: -6,
		flags: {contact: 1, protect: 1, mirror: 1},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Steel Roller", target);
		},
		target: "normal",
		type: "Steel",
	},
	venomgrip: {
		num: 933,
		accuracy: 100,
		basePower: 90,
		category: "Physical",
		shortDesc: "User & Target: Cannot switch. Poisons both.",
		name: "Venom Grip",
		pp: 10,
		priority: 0,
		flags: {bite: 1, contact: 1, protect: 1, mirror: 1},
		onHit(target, source, move) {
			source.addVolatile('trapped', target, move, 'trapper');
			source.trySetStatus('psn', target, move);
			target.addVolatile('trapped', source, move, 'trapper');
			target.trySetStatus('psn', source, move);
		},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Poison Fang", target);
		},
		secondary: null,
		target: "normal",
		type: "Steel",
	},
	soaringassault: {
		num: 934,
		accuracy: 100,
		basePower: 75,
		basePowerCallback(source, target, move) {
			if (!target.isGrounded()) {
				return move.basePower * 2;
			}
			return move.basePower;
		},
		category: "Physical",
		shortDesc: "Power doubles against airbone Pokemon.",
		name: "Soaring Assault",
		pp: 10,
		priority: 0,
		flags: {contact: 1, protect: 1, mirror: 1},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Supersonic Skystrike", target);
		},
		secondary: null,
		target: "normal",
		type: "Flying",
	},
	bubblejet: {
		num: 935,
		accuracy: 100,
		basePower: 50,
		category: "Special",
		shortDesc: "Usually goes first.",
		name: "Bubble Jet",
		pp: 20,
		priority: 1,
		flags: {bullet: 1, protect: 1, mirror: 1},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Bubble", target);
		},
		secondary: null,
		target: "normal",
		type: "Water",
	},
	steelbullets: {
		num: 936,
		accuracy: 100,
		basePower: 15,
		category: "Special",
		shortDesc: "Hits 4-10 times in one turn.",
		name: "Steel Bullets",
		pp: 20,
		priority: 0,
		flags: {bullet: 1, protect: 1, mirror: 1},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Flash Cannon", target);
		},
		multihit: [4, 10],
		secondary: null,
		target: "normal",
		type: "Steel",
	},
	backupcall: {
		num: 937,
		accuracy: true,
		basePower: 0,
		category: "Status",
		shortDesc: "Next turn, active Pokemon switch out.",
		name: "Backup Call",
		pp: 20,
		priority: 0,
		flags: {protect: 1, mirror: 1},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Baton Pass", target);
		},
		slotCondition: 'backupcall',
		condition: {
			duration: 2,
			onEnd(source) {
				if (!this.canSwitch(source.side) || source.forceSwitchFlag || source.switchFlag) return;
				for (const side of this.sides) {
					for (const active of side.active) {
						active.switchFlag = false;
					}
				}
				source.switchFlag = true;
				this.add('-activate', source, 'move: Backup Call');
			},
		},
		secondary: null,
		target: "self",
		type: "Fighting",
	},
	fairdeal: {
		num: 938,
		accuracy: 95,
		basePower: 80,
		category: "Physical",
		shortDesc: "Lowers defense of user and target by 1 stage.",
		name: "Fair Deal",
		pp: 20,
		priority: 0,
		flags: {contact: 1, protect: 1, mirror: 1},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Play Rough", target);
			this.add('-anim', source, "Hold Hands", target);
		},
		secondary: {
			boosts: {
				def: -1,
			},
		},
		self: {
			boosts: {
				def: -1,
			},
		},
		target: "normal",
		type: "Fairy",
	},
	postponerage: {
		num: 939,
		accuracy: 90,
		basePower: 40,
		basePowerCallback(pokemon, target, move) {
			let bp = move.basePower;
			const postponerageData = pokemon.volatiles['postponerage'];
			if (postponerageData?.hitCount) {
				bp *= Math.pow(2, postponerageData.contactHitCount);
			}
			if (postponerageData && pokemon.status !== 'slp') {
				postponerageData.hitCount++;
				postponerageData.contactHitCount++;
				if (postponerageData.hitCount < 3) {
					postponerageData.duration = 2;
				}
			}
			this.debug("BP: " + bp);
			return bp;
		},
		category: "Special",
		shortDesc: "Power doubles with each hit. Repeats for 3 turns.",
		name: "Postpone Rage",
		pp: 5,
		priority: 0,
		flags: {protect: 1, mirror: 1, noparentalbond: 1, failinstruct: 1},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Night Daze", target);
		},
		onModifyMove(move, pokemon, target) {
			if (pokemon.volatiles['postponerage'] || pokemon.status === 'slp' || !target) return;
			pokemon.addVolatile('postponerage');
			// @ts-ignore
			// TS thinks pokemon.volatiles['postponerage'] doesn't exist because of the condition on the return above
			// but it does exist now because addVolatile created it
			pokemon.volatiles['postponerage'].targetSlot = move.sourceEffect ? pokemon.lastMoveTargetLoc : pokemon.getLocOf(target);
		},
		onAfterMove(source, target, move) {
			const postponerageData = source.volatiles["postponerage"];
			if (
				postponerageData &&
				postponerageData.hitCount === 5 &&
				postponerageData.contactHitCount < 5
				// this conditions can only be met in gen7 and gen8dlc1
				// see `disguise` and `iceface` abilities in the resp mod folders
			) {
				source.addVolatile("rolloutstorage");
				source.volatiles["rolloutstorage"].contactHitCount =
					postponerageData.contactHitCount;
			}
		},
		condition: {
			duration: 1,
			onLockMove: 'postponerage',
			onStart() {
				this.effectState.hitCount = 0;
				this.effectState.contactHitCount = 0;
			},
			onResidual(target) {
				if (target.lastMove && target.lastMove.id === 'struggle') {
					// don't lock
					delete target.volatiles['postponerage'];
				}
			},
		},
		secondary: null,
		target: "normal",
		type: "Dark",
	},
	derust: {
		num: 940,
		accuracy: true,
		basePower: 0,
		category: "Status",
		shortDesc: "Steel: Looses type; Cures status; +1/4 max HP.",
		name: "Derust",
		pp: 10,
		priority: 0,
		flags: {heal: 1, snatch: 1},
		onTryMove(pokemon, target, move) {
			if (pokemon.hasType('Steel')) return;
			this.add('-fail', pokemon, 'move: Derust');
			this.attrLastMove('[still]');
			return null;
		},
		onHit(pokemon) {
			const success = !!this.heal(this.modify(pokemon.maxhp, 0.33));
			return pokemon.cureStatus() || success;
		},
		self: {
			onHit(pokemon) {
				pokemon.setType(pokemon.getTypes(true).map(type => type === "Steel" ? "???" : type));
				this.add('-start', pokemon, 'typechange', pokemon.getTypes().join('/'), '[from] move: Derust');
			},
		},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Iron Defense", target);
		},
		secondary: null,
		target: "self",
		type: "Steel",
	},
	lightabsorption: {
		num: 941,
		accuracy: true,
		basePower: 0,
		category: "Status",
		shortDesc: "Heals 33%, Sun: 66%, +1 SpA, Electric Terrain: +2.",
		name: "Light Absorption",
		pp: 5,
		priority: 0,
		flags: {snatch: 1, heal: 1},
		onHit(pokemon) {
			let factor = 0.333;
			if (['sunnyday', 'desolateland'].includes(pokemon.effectiveWeather())) {
				factor = 0.667;
			}
			const success = !!this.heal(this.modify(pokemon.maxhp, factor));
			if (!success) {
				this.add('-fail', pokemon, 'heal');
				return this.NOT_FAIL;
			}
			return success;
		},
		onModifyMove(move, pokemon) {
			if (this.field.isTerrain('electricterrain') && pokemon.isGrounded()) move.boosts = {spa: 2};
		},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Charge", target);
		},
		boosts: {
			spa: 1,
		},
		secondary: null,
		target: "self",
		type: "Electric",
	},
	basaltlayer: {
		num: 942,
		accuracy: true,
		basePower: 0,
		category: "Status",
		shortDesc: "Removes hazards and terrain. 3 turns: cannot be set-up.",
		name: "Basalt Layer",
		pp: 20,
		priority: 0,
		flags: {},
		pseudoWeather: 'basaltlayer',
		onTryMove(pokemon, target, move) {
			if (this.field.getPseudoWeather('basaltlayer')) {
				this.add('-fail', pokemon, 'move: Basalt Layer');
				this.hint("Basalt Layer cannot be used once it is active.");
				this.attrLastMove('[still]');
				return null;
			}
		},
		onHit(pokemon) {
			let success = false;
			if (this.field.clearTerrain()) success = true;
			const removeAll = ['spikes', 'toxicspikes', 'stealthrock', 'stickyweb', 'gmaxsteelsurge'];
			const sides = [pokemon.side, ...pokemon.side.foeSidesWithConditions()];
			for (const side of sides) {
				for (const sideCondition of removeAll) {
					if (side.removeSideCondition(sideCondition)) {
						this.add('-sideend', side, this.dex.conditions.get(sideCondition).name);
						success = true;
					}
				}
			}
			if (success) this.add('-activate', pokemon, 'move: Tidy Up');
			return !!this.field.addPseudoWeather('basaltlayer') || success;
		},
		condition: {
			duration: 4,
			onFieldStart(target, source) {
				this.add('-fieldstart', 'move: Basalt Layer', '[of] ' + source);
			},
			onFieldResidualOrder: 27,
			onFieldResidualSubOrder: 1,
			onTryMovePriority: 1,
			onTryMove(attacker, defender, effect) {
				if (['stealthrock', 'spikes', 'toxicspikes', 'stickyweb', 'electricterrain', 'grassyterrain', 'mistyterrain', 'psychicterrain'].includes(effect.id)) {
					this.debug('Basalt Layer denial');
					this.add('-fail', attacker, effect, '[from] Basalt Layer');
					this.hint("Basalt Layer blocks the use of hazards and terrains.");
					this.attrLastMove('[still]');
					return null;
				}
			},
			onFieldEnd() {
				this.add('-fieldend', 'move: Basalt Layer');
			},
		},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Tar Shot", target);
		},
		secondary: null,
		target: "self",
		type: "Fire",
	},
	hourglass: {
		num: 943,
		accuracy: true,
		basePower: 0,
		category: "Status",
		shortDesc: "2 turns after: Puts active Pokemon to sleep.",
		name: "Hour Glass",
		pp: 5,
		priority: 0,
		flags: {authentic: 1},
		pseudoWeather: 'hourglass',
		condition: {
			duration: 3,
			onFieldStart(field, source) {
				this.add('-fieldstart', 'move: Hour Glass', '[of] ' + source);
			},
			onFieldResidualOrder: 27,
			onFieldResidualSubOrder: 3,
			onFieldResidual() {
				this.add('-message', `The Hour Glass is ticking!`);
			},
			onFieldEnd() {
				this.add('-fieldend', 'move: Hour Glass');
				for (const pokemon of this.getAllActive()) {
					pokemon.trySetStatus('slp', this.effectState.source);
				}
			},
		},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Sand Attack", source);
			this.add('-anim', source, "Sand Attack", target);
		},
		target: "normal",
		type: "Ground",
	},
	cosmicsymbols: {
		num: 944,
		accuracy: 100,
		basePower: 100,
		category: "Special",
		shortDesc: "Lowers foe(s) highest stat by 2.",
		name: "Cosmic Symbols",
		pp: 5,
		priority: 0,
		flags: {protect: 1, mirror: 1},
		onHit(target, source, move, effect) {
			this.effectState.bestStat = target.getBestStat(false, true);
			if (this.effectState.bestStat === 'atk') {
				this.boost({atk: -2}, target, source, move);
			} else if (this.effectState.bestStat === 'def') {
				this.boost({def: -2}, target, source, move);
			} else if (this.effectState.bestStat === 'spa') {
				this.boost({spa: -2}, target, source, move);
			} else if (this.effectState.bestStat === 'spd') {
				this.boost({spd: -2}, target, source, move);
			} else {
				this.boost({spe: -2}, target, source, move);
			}
			
		},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Judgment", target);
		},
		secondary: null,
		target: "allAdjacentFoes",
		type: "Psychic",
	},
	glassshimmer: {
		num: 945,
		accuracy: 100,
		basePower: 120,
		category: "Special",
		shortDesc: "Lowers the user's Defense and Sp. Def by 1.",
		name: "Glass Shimmer",
		pp: 5,
		priority: 0,
		flags: {protect: 1, mirror: 1},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Diamond Storm", target);
		},
		self: {
			boosts: {
				def: -1,
				spd: -1,
			},
		},
		secondary: null,
		target: "normal",
		type: "Rock",
	},
	battleaxe: {
		num: 946,
		accuracy: 95,
		basePower: 95,
		category: "Physical",
		shortDesc: "High critical ratio. If crit: -1 Defense.",
		name: "Battle Axe",
		pp: 10,
		priority: 0,
		flags: {contact: 1, protect: 1, mirror: 1, slicing: 1},
		onHit(target, source, move) {
			if (target.getMoveHitData(move).crit) {
				this.boost({def: -1}, target, target);
			}
		},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Sharpen", source);
			this.add('-anim', source, "Slash", target);
		},
		critRatio: 2,
		secondary: null,
		target: "normal",
		type: "Steel",
	},
	riskyway: {
		num: 947,
		accuracy: 100,
		basePower: 400,
		category: "Physical",
		shortDesc: "Hits Pokemon sharing the user's type.",
		name: "Risky Way",
		pp: 5,
		priority: 0,
		flags: {protect: 1, mirror: 1},
		ignoreImmunity: {'Normal': true},
		onTryImmunity(target, source) {
			if (!target.hasType(source.getTypes())) {
				return false;
			}
		},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Giga Impact", target);
		},
		secondary: null,
		target: "normal",
		type: "Normal",
	},
	bodycharge: {
		num: 948,
		accuracy: 80,
		basePower: 150,
		category: "Physical",
		shortDesc: "33% recoil. User: 0.5x damage until next move.",
		name: "Body Charge",
		pp: 5,
		priority: 0,
		flags: {contact: 1, protect: 1, mirror: 1},
		self: {
			volatileStatus: 'bodycharge',
		},
		condition: {
			noCopy: true,
			onStart(pokemon) {
				this.add('-singlemove', pokemon, 'Body Charge', '[silent]');
			},
			onSourceModifyDamage() {
				return this.chainModify(0.5);
			},
			onBeforeMovePriority: 100,
			onBeforeMove(pokemon) {
				this.debug('removing Body Charge drawback before attack');
				pokemon.removeVolatile('bodycharge');
			},
		},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Head Smash", target);
		},
		recoil: [33, 100],
		secondary: null,
		target: "normal",
		type: "Steel",
	},
	mindclaw: {
		num: 949,
		accuracy: 100,
		basePower: 95,
		category: "Physical",
		shortDesc: "Targets opponent's lower stat and lowers it.",
		name: "Mind Claw",
		pp: 10,
		priority: 0,
		flags: {contact: 1, protect: 1, mirror: 1},
		onModifyMove(move, source, target) {
			if (target.getStat('def', false, true) >= target.getStat('spd', false, true)) {
				move.defensiveCategory = 'Special';
			} else {
				move.defensiveCategory = 'Physical';
			}
		},
		onAfterMove(source, target) {
			if (target.getStat('def', false, true) >= target.getStat('spd', false, true)) {
				this.boost({spd: -1}, target);
			} else {
				this.boost({def: -1}, target);
			}
		},
		onHit(target, source, move) {
			this.hint(move.defensiveCategory + " Mind Claw");
		},
		onAfterSubDamage(target, source, move) {
			this.hint(move.defensiveCategory + " Mind Claw");
		},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Dragon Claw", target);
		},
		secondary: null,
		target: "normal",
		type: "Fighting",
	},
	spiritroar: {
		num: 950,
		accuracy: 100,
		basePower: 75,
		category: "Special",
		shortDesc: "Crits/Ignores abilities. Stoleagle: Switch uses move.",
		name: "Spirit Roar",
		pp: 15,
		priority: 0,
		flags: {protect: 1, mirror: 1, sound: 1, authentic: 1},
		willCrit: true,
		ignoreAbility: true,
		onAfterMove(pokemon) {
			if (pokemon.species.baseSpecies === 'Stoleagle') {
				pokemon.side.addSlotCondition(pokemon, 'spiritroar')
				this.add('-message', `${pokemon.name} will encourage a Pokemon!`);
				pokemon.switchFlag = true;
			}
		},
		condition: {
			onSwap(target) {
				this.add('-message', `${target.name} was encouraged by Stoleagle!`);
				this.actions.useMove("Spirit Roar", target);
				target.side.removeSlotCondition(target, 'spiritroar');
			},
		},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Echoed Voice", target);
		},
		secondary: null,
		target: "normal",
		type: "Normal",
	},
	dynamicassault: {
		num: 951,
		accuracy: 100,
		basePower: 60,
		basePowerCallback(pokemon, target, move) {
			return 60 + 15 * pokemon.side.active.length;
		},
		category: "Special",
		shortDesc: "+15 power for every non fainted ally.",
		name: "Dynamic Assault",
		pp: 10,
		priority: 0,
		flags: {protect: 1, mirror: 1},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Moonlight", target);
			this.add('-anim', source, "Close Combat", target);
		},
		secondary: null,
		target: "normal",
		type: "Fairy",
	},
	chasedown: {
		num: 952,
		accuracy: 100,
		basePower: 50,
		basePowerCallback(pokemon, target, move) {
			// You can't get here unless the chasedown succeeds
			if (target.beingCalledBack || target.switchFlag) {
				this.debug('Chase Down damage boost');
				return move.basePower * 2;
			}
			return move.basePower;
		},
		category: "Physical",
		shortDesc: "If a foe is switching out, hits it at 2x power.",
		name: "Chase Down",
		pp: 10,
		priority: 0,
		flags: {contact: 1, protect: 1, mirror: 1},
		onPrepareHit: function(target, source, move) {
			this.attrLastMove('[still]');
			this.add('-anim', source, "Pursuit", target);
		},
		beforeTurnCallback(pokemon) {
			for (const side of this.sides) {
				if (side.hasAlly(pokemon)) continue;
				side.addSideCondition('chasedown', pokemon);
				const data = side.getSideConditionData('chasedown');
				if (!data.sources) {
					data.sources = [];
				}
				data.sources.push(pokemon);
			}
		},
		onModifyMove(move, source, target) {
			if (target?.beingCalledBack || target?.switchFlag) move.accuracy = true;
		},
		onTryHit(target, pokemon) {
			target.side.removeSideCondition('chasedown');
		},
		condition: {
			duration: 1,
			onBeforeSwitchOut(pokemon) {
				this.debug('Chase Down start');
				let alreadyAdded = false;
				pokemon.removeVolatile('destinybond');
				for (const source of this.effectState.sources) {
					if (!source.isAdjacent(pokemon) || !this.queue.cancelMove(source) || !source.hp) continue;
					if (!alreadyAdded) {
						this.add('-activate', pokemon, 'move: Chase Down');
						alreadyAdded = true;
					}
					// Run through each action in queue to check if the Chase Down user is supposed to Mega Evolve this turn.
					// If it is, then Mega Evolve before moving.
					if (source.canMegaEvo || source.canUltraBurst) {
						for (const [actionIndex, action] of this.queue.entries()) {
							if (action.pokemon === source && action.choice === 'megaEvo') {
								this.actions.runMegaEvo(source);
								this.queue.list.splice(actionIndex, 1);
								break;
							}
						}
					}
					this.actions.runMove('chasedown', source, source.getLocOf(pokemon));
				}
			},
		},
		secondary: null,
		target: "normal",
		type: "Ghost",
	},
};